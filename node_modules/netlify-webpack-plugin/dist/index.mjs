const csp = cspPolicy => {
  const [firstPolicy, ...morePolicies] = Object.keys(cspPolicy).map(directive => `${directive} ${cspPolicy[directive].join(' ')}`);

  if (morePolicies.length > 0) {
    return [firstPolicy, morePolicies];
  }

  return firstPolicy;
};

/**
 * Headers can be either single or multi-valued.
 * For single valued headers the value can be a string or number, or
 * it can be an array with the first argument being a string or number, the value of the header
 * and the second argument being an object or array containing the tokens with their values.
 * For the tokens if the value is a boolean is token is name is included if the value is true,
 * otherwise the value is [tokenName]=[tokenValue]; . If tokens is an array tokens are included as [token];
 * For Multi-valued headers the value should be an array of the single valued headers, or an object
 * in the case of an object if the value for a key is a boolean than the header value
 * will be included conditionally. Otherwise the value will be:
 * [key]=[value according to single value spec]
 */
function isSimpleHeaderValue(value) {
  return typeof value === 'string' || typeof value === 'number' || value instanceof String || value instanceof Number;
}

function isBoolean(value) {
  return typeof value === 'boolean' || value instanceof Boolean;
}

function isParameterizedHeaderValue(value) {
  if (Array.isArray(value) && value.length === 2) {
    const [parameterValue, tokens] = value;

    if (isSimpleHeaderValue(parameterValue) && tokens !== null && typeof tokens === 'object') {
      if (Array.isArray(tokens)) {
        return tokens.every(v => isSimpleHeaderValue(v));
      }

      return Object.values(tokens).every(v => isBoolean(v) || isSimpleHeaderValue(v));
    }
  }

  return false;
}

function writeParameterizedHeaderValue(value) {
  const tokenStrings = Array.isArray(value[1]) ? value[1].map(v => `${v}`) : Object.entries(value[1]).map(([key, v]) => {
    if (isBoolean(v)) {
      return v ? key : null;
    }

    return `${key}=${v}`;
  }).filter(v => v != null);
  return `${value[0]}${tokenStrings.length > 0 ? `; ${tokenStrings.join('; ')}` : ''}`;
}

function isSingleValueHeader(value) {
  return isParameterizedHeaderValue(value) || isSimpleHeaderValue(value);
}

function writeSingleValueHeader(header, value) {
  const headerValue = isSimpleHeaderValue(value) ? `${value}` : writeParameterizedHeaderValue(value);
  return `  ${header}: ${headerValue}`;
}

function isMultiValueHeader(value) {
  if (value != null && typeof value === 'object') {
    if (Array.isArray(value)) {
      return !isParameterizedHeaderValue(value) && value.every(v => isSingleValueHeader(v));
    } else {
      return Object.values(value).every(v => isBoolean(v) || isSingleValueHeader(v));
    }
  }

  return false;
}

function writeMultiValueHeader(header, value) {
  return Array.isArray(value) ? value.map(v => writeSingleValueHeader(header, v)) : Object.keys(value).map(key => {
    const v = value[key];

    if (isBoolean(v)) {
      return v ? key : null;
    }

    return `${key}=${isSimpleHeaderValue(v) ? v : writeParameterizedHeaderValue(v)}`;
  }).filter(v => v != null).map(v => writeSingleValueHeader(header, v));
}

function writeHeaders(header, value) {
  if (value != null) {
    if (isSingleValueHeader(value)) {
      return [writeSingleValueHeader(header, value)];
    } else if (isMultiValueHeader(value)) {
      return writeMultiValueHeader(header, value);
    }
  }

  return [];
}

const createHeaderFile = headers => Object.keys(headers).map(path => {
  const headerValues = Object.keys(headers[path]).map(header => writeHeaders(header, headers[path][header])).reduce((acc, next) => {
    acc.push(...next);
    return acc;
  }, []);

  if (headerValues) {
    return [`${path}`, ...headerValues];
  }

  return [];
}).reduce((acc, next) => {
  acc.push(...next);
  return acc;
}, []).join('\n');

function writeConditions(conditions) {
  if (conditions) {
    return Object.keys(conditions).map(k => {
      const key = k;

      if (conditions[key] && conditions[key].length > 0) {
        const capitalized = `${key[0].toUpperCase()}${key.substr(1)}`;
        return `${capitalized}=${conditions[key].join(',')}`;
      }

      return null;
    }).filter(v => v != null);
  }

  return [];
}

function writeQueryParams(query) {
  if (query) {
    return Object.keys(query).map(param => `${param}=${query[param]}`);
  }

  return [];
}

const createRedirectFile = patterns => patterns.map(({
  from,
  query,
  to,
  status = 301,
  force,
  conditions
}) => [from, ...writeQueryParams(query), to, `${status}${force ? '!' : ''}`, ...writeConditions(conditions)].join('    ')).join('\n');

function tapEmit(compiler) {
  if ('hooks' in compiler) {
    return (name, syncHook) => compiler.hooks.emit.tap(name, syncHook);
  } else {
    // use the the legacy api if that's what is provided.
    return (_, syncHook) => {
      compiler.plugin('emit', (compilation, callback) => {
        syncHook(compilation);
        callback();
      });
    };
  }
} // Given a configuration writes it out as _headers and _redirects files


class NetlifyPlugin {
  constructor(configuration) {
    this.configuration = configuration;
  }

  apply(compiler) {
    tapEmit(compiler)('NetlifyPlugin', compilation => {
      if (this.configuration.headers) {
        const headersFile = createHeaderFile(this.configuration.headers);
        compilation.assets._headers = {
          source: () => headersFile,
          size: () => headersFile.length
        };
      }

      if (this.configuration.redirects) {
        const redirects = createRedirectFile(this.configuration.redirects);
        compilation.assets._redirects = {
          source: () => redirects,
          size: () => redirects.length
        };
      }
    });
  }

}

export { NetlifyPlugin, csp };
//# sourceMappingURL=index.mjs.map
